https://www.jianshu.com/p/76959115d486  
**1.JVM--JMM--GC**  

**1.1 程序计数器**  
　　线程私有，生命周期同线程，当前线程的行号指示器。cpu在一个确定的时刻都会执行一条线程中的指令，
为了线程切换可以恢复到正确的执行位置，每个线程都需要一个程序计数器。不同线程的程
序计数器互不影响，独立存储。  
　　注：如果线程执行的是java方法，那么计数器记录虚拟机字节码指令的地址。如果为native
方法【底层方法】，那么计数器为空。  
　　**该块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域**  

**1.2虚拟机栈**  
　　线程私有，生命周期同线程，栈描述的是Java方法执行的内存模型。  
　　帧栈：用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接（Dynamic Linking）,方法返回值和异常分派（Dispatch Exception）。      
　　每个线程方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。  
　　栈帧大小确定时间：编译期确定，不受运行期数据影响。  
　　平时所说的栈是指局部变量表。  
　　局部变量表：  
　　一片连续的内存空间，用来存放方法参数，以及方法内部定义的局部变量。存放着编译期间已知的数据类型
（八大基本类型和对象引用（reference类型），returnAdress类型。它的最小的局部变量表空间单位为Slot，
虚拟机中没有指明Slot的大小，但在jvm中，long和double类型数据明确规定为64位，这俩个类型占俩个Slot，其他
基本类型固定占用1个Slot。  
　　reference类型：与基本类型不同的是它不等同本身，即使是String，内部也是char数组组成，它可能是
是指向一个对象起始位置指针，也可能指向一个代表对象的句柄或其他与该对象有关的位置。  
　　returnAddress类型：指向一条字节码指令的地址。    
　　注：局部变量表所需要的内存空间是在编译期间就分好的，当进入一个方法时,这个方法在栈中的空间大小是  
完全确定的，在方法运行期间不会改变局部变量表大小。  
　　Java虚拟机栈可能出现的俩种异常：  
　　1.线程请求的深度大于虚拟机允许的栈深度，将跑出StackOverflowError。  
　　2.虚拟机栈空间可以动态扩展，当动态扩展无法申请到足够的空间时，将跑出OutOfMemory异常。  

**1.3本地方法栈**  
　　本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方
法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写
的文件，可能就是native方法所调用的c代码。  

**1.4堆**  
　　对于大多数应用来说，堆是java虚拟机管理内存最大的一块内存区域，因为堆内存存放的对象是线程共享的，所以
多线程的时候也需要同步机制。  
　　java虚拟机规范对这块的描述是:所有对象实例及数组都要在堆上分配内存，但随着JIT编译器的发展和逃逸分析技
术的成熟，这个说法也不是那么绝对，但是大多数情况都是这样的。  
　　即时编译器:可以把Java的字节码，包括需要被解释的指令的程序转换成可以直接发送给处理器的指令的程序  
　　逃逸分析:通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直
接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者其其它线程所引用。  
　　注意:它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由
于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代，再细致点还有Eden(伊甸园)空间之类的不做深究。
根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设
为固定大小，也可以扩展。 当前主流的虚拟机如HotPot都能按扩展实现(通过设置 -Xmx和-Xms)，如果堆中没有内存内存
完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)  

**1.5方法区**  
　　方法区同堆一样，是所有线程共享的区域，为了区分堆，又称为非堆。  
　　用于存储已被虚拟机加载的类信息，常量，静态变量。  
　　运行时常量池：  
　　是方法区的一部分，class文件除有类的字段，接口，方法等描述信息之外，还有常量池用于存放编译期间生成的各种字
面量和符号引用。  
　　在老版jdk，方法区也被称为永久代【因为没有强制要求方法区必须实现垃圾回收，HotSpot虚拟机以永久代来实现方法区，
从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，
Hotspot虚拟机便将运行时常量池从永久代移除了。】  
`public class StringIntern { `   
　　`//运行如下代码探究运行时常量池的位置 `   
　　` public static void main(String[] args) throws Throwable {`   
　　　　` //用list保持着引用 防止full gc回收常量池  `  
　　　　`  List<String> list = new ArrayList<String>();  `  
　　　　`  int i = 0;  `  
　　　　`  while(true){  `  
　　　　　　`  list.add(String.valueOf(i++).intern());  `  
　　　　` }  `  
　　` } `  
` }`  


